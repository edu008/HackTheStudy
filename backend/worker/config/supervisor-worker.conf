[supervisord]
nodaemon=true
user=root
logfile=/var/log/supervisord.log
logfile_maxbytes=50MB
logfile_backups=5
loglevel=info
pidfile=/tmp/supervisor-worker.pid
childlogdir=/var/log/
umask=022
identifier=supervisor-worker
directory=/app
nocleanup=true
minfds=65536
minprocs=200
strip_ansi=true

[unix_http_server]
file=/tmp/supervisor-worker.sock
chmod=0760
chown=root:root

[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

[supervisorctl]
serverurl=unix:///tmp/supervisor-worker.sock

[program:worker]
command=python -m tasks
directory=/app
user=root
autostart=true
autorestart=true
startsecs=15
startretries=5
stopasgroup=true
killasgroup=true
stopsignal=TERM
stopwaitsecs=60
autokill=true
redirect_stderr=true
stdout_logfile=/proc/1/fd/1
stdout_logfile_maxbytes=0
stderr_logfile=/proc/1/fd/2
stderr_logfile_maxbytes=0
priority=100
environment=LOG_PREFIX="[WORKER] ",LOG_LEVEL="INFO",PYTHONUNBUFFERED="1",LOG_API_REQUESTS="true",RUN_MODE="worker",FLASK_APP="app.py",C_FORCE_ROOT="1",DO_APP_PLATFORM="true",USE_COLORED_LOGS="false",CELERY_POOL="solo",CELERY_WORKER_CONCURRENCY="1"

[program:healthcheck]
command=python -c "import http.server, socketserver, json, time, psutil, os, socket; class HealthHandler(http.server.BaseHTTPRequestHandler): def do_GET(self): if self.path == '/ping' or self.path == '/': self.send_response(200); self.send_header('Content-Type', 'application/json'); self.end_headers(); health_data = {'status': 'healthy', 'timestamp': time.time(), 'memory_percent': psutil.virtual_memory().percent, 'cpu_percent': psutil.cpu_percent(interval=0.1), 'container': os.environ.get('CONTAINER_TYPE'), 'hostname': socket.gethostname(), 'platform': 'digitalocean'}; self.wfile.write(json.dumps(health_data).encode()); elif self.path == '/metrics': self.send_response(200); self.send_header('Content-Type', 'text/plain'); self.end_headers(); metrics = ['# TYPE memory_usage gauge', f'memory_usage {psutil.virtual_memory().percent}', '# TYPE cpu_usage gauge', f'cpu_usage {psutil.cpu_percent(interval=0.1)}']; self.wfile.write('\\n'.join(metrics).encode()); else: self.send_response(404); self.end_headers(); def log_message(self, *args): pass; port = int(os.environ.get('HEALTH_PORT', 8080)); print(f'Starting health server on port {port}'); socketserver.TCPServer(('', port), HealthHandler).serve_forever()"
user=root
autostart=true
autorestart=true
startsecs=5
startretries=3
priority=200
environment=PYTHONUNBUFFERED="1",HEALTH_PORT="8080"
redirect_stderr=true
stdout_logfile=/proc/1/fd/1
stdout_logfile_maxbytes=0
stderr_logfile=/proc/1/fd/2
stderr_logfile_maxbytes=0
stopasgroup=true
killasgroup=true

[program:self_monitor]
command=python -c "import time, psutil, os, logging; logging.basicConfig(level=logging.INFO, format='[%%(levelname)s] MONITOR: %%(message)s'); CHECK_INTERVAL=30; while True: try: cpu = psutil.cpu_percent(interval=1); mem = psutil.virtual_memory().percent; disk = psutil.disk_usage('/').percent; if cpu > 90: logging.warning(f'KRITISCH: CPU-Auslastung sehr hoch: {cpu}%%'); elif cpu > 80: logging.warning(f'WARNUNG: CPU-Auslastung hoch: {cpu}%%'); if mem > 90: logging.warning(f'KRITISCH: RAM-Auslastung sehr hoch: {mem}%%'); elif mem > 80: logging.warning(f'WARNUNG: RAM-Auslastung hoch: {mem}%%'); if disk > 90: logging.warning(f'KRITISCH: Festplattenspeicher fast voll: {disk}%%'); logging.info(f'CPU: {cpu}%%, RAM: {mem}%%, Disk: {disk}%%'); except Exception as e: logging.error(f'Monitoring-Fehler: {str(e)}'); time.sleep(CHECK_INTERVAL)"
user=root
autostart=true
autorestart=true
startsecs=5
startretries=3
priority=300
environment=PYTHONUNBUFFERED="1"
redirect_stderr=true
stdout_logfile=/proc/1/fd/1
stdout_logfile_maxbytes=0
stderr_logfile=/proc/1/fd/2
stderr_logfile_maxbytes=0
stopasgroup=true
killasgroup=true

[group:worker]
programs=worker,healthcheck,self_monitor
priority=999 